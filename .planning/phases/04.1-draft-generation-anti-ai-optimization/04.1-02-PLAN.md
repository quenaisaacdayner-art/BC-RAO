---
phase: 04.1-draft-generation-anti-ai-optimization
plan: 02
type: execute
wave: 2
depends_on: ["04.1-01"]
files_modified:
  - bc-rao-api/app/generation/blacklist_validator.py
  - bc-rao-api/app/generation/generation_service.py
  - bc-rao-api/tests/test_blacklist_validator.py
autonomous: true

must_haves:
  truths:
    - "AI pattern detection is blocking — detected posts trigger up to 2 regeneration attempts with stronger anti-pattern instructions"
    - "AI detection catches symmetrical structure, tidy endings, enumerated parallel structure, hedge-then-affirm, generic descriptors"
    - "Regeneration attempt count and final AI pattern count are stored in generation_params for monitoring"
    - "Max 3 total attempts (1 original + 2 retries) — cost explosion prevented"
  artifacts:
    - path: "bc-rao-api/app/generation/blacklist_validator.py"
      provides: "Expanded AI_TELL_PATTERNS with 6+ new detection patterns"
      contains: "AI-symmetrical-structure"
    - path: "bc-rao-api/app/generation/generation_service.py"
      provides: "Blocking regeneration loop in generate_draft pipeline"
      contains: "MAX_REGENERATION_ATTEMPTS"
    - path: "bc-rao-api/tests/test_blacklist_validator.py"
      provides: "Updated tests covering new AI detection patterns"
      contains: "AI-tidy-ending"
  key_links:
    - from: "bc-rao-api/app/generation/generation_service.py"
      to: "bc-rao-api/app/generation/blacklist_validator.py"
      via: "detect_ai_patterns() called in regeneration loop"
      pattern: "detect_ai_patterns.*for attempt"
    - from: "bc-rao-api/app/generation/generation_service.py"
      to: "bc-rao-api/app/generation/prompt_builder.py"
      via: "build_prompt() called with anti_pattern_feedback on retry"
      pattern: "anti_pattern_feedback"
---

<objective>
Expand AI-tell detection patterns to catch 6 additional anti-patterns (symmetrical structure, tidy endings, enumeration, hedge-affirm, generic descriptors, excessive enthusiasm) and convert the informational-only AI detection in generation_service.py into a blocking regeneration loop that automatically retries up to 2 times with escalating anti-pattern instructions.

Purpose: Currently AI pattern detection only logs warnings — the draft is stored as-is regardless of AI tells. This plan makes detection actionable: detected patterns trigger automatic regeneration with feedback about what to fix, producing substantially better drafts before the user ever sees them.

Output: Updated blacklist_validator.py with expanded patterns, updated generation_service.py with blocking loop, updated tests.
</objective>

<execution_context>
@C:/Users/quena/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/quena/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.1-draft-generation-anti-ai-optimization/04.1-RESEARCH.md
@.planning/debug/generic-ai-detectable-drafts.md
@.planning/phases/04.1-draft-generation-anti-ai-optimization/04.1-01-SUMMARY.md
@bc-rao-api/app/generation/blacklist_validator.py
@bc-rao-api/app/generation/generation_service.py
@bc-rao-api/app/generation/prompt_builder.py
@bc-rao-api/tests/test_blacklist_validator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand AI detection patterns and update tests</name>
  <files>bc-rao-api/app/generation/blacklist_validator.py, bc-rao-api/tests/test_blacklist_validator.py</files>
  <action>
Read the existing test_blacklist_validator.py FIRST to understand what tests exist and what they assert, so changes don't break them.

**blacklist_validator.py — Add 6 new patterns to AI_TELL_PATTERNS list:**

Append these 6 new compiled regex patterns after the existing 6 patterns in the AI_TELL_PATTERNS list:

1. **AI-symmetrical-structure** — Detect suspiciously balanced intro-body-conclusion (3 paragraphs where first and last are both short, middle is long):
   ```python
   (re.compile(
       r'^.{50,200}\n\n.{200,}\n\n.{50,200}$', re.DOTALL
   ), "AI-symmetrical-structure", "Suspiciously balanced intro-body-conclusion structure"),
   ```

2. **AI-tidy-ending** — Detect tidy moral/summary endings:
   ```python
   (re.compile(
       r'(?:In summary|Overall|All in all|At the end of the day|The takeaway|'
       r'The moral|Looking back|In hindsight|To sum up|The bottom line|'
       r'In conclusion|To conclude|Ultimately)[,:]',
       re.IGNORECASE
   ), "AI-tidy-ending", "Tidy wrap-up ending phrase"),
   ```

3. **AI-enumeration** — Detect enumerated parallel structure (sequential ordinals):
   ```python
   (re.compile(
       r'(?:^|\n)\s*(?:First|Second|Third|Fourth|Finally|Lastly|Next|Then)(?:ly)?[,:\s]',
       re.MULTILINE | re.IGNORECASE
   ), "AI-enumeration", "Enumerated parallel structure"),
   ```

4. **AI-hedge-affirm** — Detect balanced hedge-then-affirm pattern:
   ```python
   (re.compile(
       r'\b(?:While|Although|Though)\b.{20,80}\b(?:however|nevertheless|still|'
       r'that said|on the other hand)\b',
       re.IGNORECASE
   ), "AI-hedge-affirm", "Balanced hedge-then-affirm pattern"),
   ```

5. **AI-generic-descriptor** — Detect generic descriptors without specifics:
   ```python
   (re.compile(
       r'\b(?:various|numerous|several|multiple|a number of|a variety of)\s+'
       r'(?:tools|options|solutions|approaches|methods|techniques|strategies|resources)\b',
       re.IGNORECASE
   ), "AI-generic-descriptor", "Generic descriptor without specifics"),
   ```

6. **AI-over-enthusiasm** — Detect 3+ exclamation marks in a single post (but only trigger if text is under 500 words to allow naturally exclamation-heavy long posts):
   ```python
   (re.compile(
       r'(?:!.*){3,}',
       re.DOTALL
   ), "AI-over-enthusiasm", "Excessive exclamation marks (3+ in post)"),
   ```

Also update the severity mapping in `detect_ai_patterns()`: add `"AI-tidy-ending"` and `"AI-symmetrical-structure"` to the high-severity set alongside existing high-severity categories.

**Note on "In conclusion"**: The existing AI_TELL_PATTERNS pattern 1 already catches "In conclusion" as a formal transition. The new AI-tidy-ending pattern adds broader coverage (Overall, All in all, etc.) and will cause double-detection for "In conclusion" which is acceptable — it simply increases the violation count for text using that phrase.

**test_blacklist_validator.py — Update tests:**

Read existing tests first. Then:
1. Add test cases for each new pattern that verify detection fires correctly
2. Add a negative test verifying normal text without AI patterns returns empty list
3. Ensure existing test cases still pass (don't change them unless they test a specific count that changed)
4. If existing tests assert exact pattern counts, update the expected counts to include new patterns
  </action>
  <verify>
Run `cd bc-rao-api && python -m pytest tests/test_blacklist_validator.py -x -v` — all tests must pass.

Run `python -c "from app.generation.blacklist_validator import AI_TELL_PATTERNS; assert len(AI_TELL_PATTERNS) >= 12; print(f'{len(AI_TELL_PATTERNS)} patterns OK')"` from bc-rao-api directory.

Run `python -c "from app.generation.blacklist_validator import detect_ai_patterns; r = detect_ai_patterns('In summary, this approach has been great overall.'); assert any(d['category'] == 'AI-tidy-ending' for d in r); print('tidy ending detected OK')"` from bc-rao-api directory.
  </verify>
  <done>
AI_TELL_PATTERNS contains 12+ patterns including all 6 new detection categories. All tests pass. New patterns correctly detect symmetrical structure, tidy endings, enumeration, hedge-affirm, generic descriptors, and over-enthusiasm.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement blocking regeneration loop in generation_service.py</name>
  <files>bc-rao-api/app/generation/generation_service.py</files>
  <action>
Read the existing generation_service.py first. The regeneration loop modifies the `generate_draft()` method, specifically wrapping Steps 5-6b in a retry loop.

**Add MAX_REGENERATION_ATTEMPTS constant** at module level (after imports):
```python
MAX_REGENERATION_ATTEMPTS = 2  # Max retries after initial generation (3 total attempts max)
```

**Add _build_anti_pattern_feedback() helper method** to GenerationService class:
```python
def _build_anti_pattern_feedback(self, ai_patterns: list, attempt: int) -> str:
    """Build escalating feedback for regeneration based on detected AI patterns."""
    categories = list(set(p["category"] for p in ai_patterns))
    descriptions = [p["description"] for p in ai_patterns]

    feedback_parts = [
        f"CRITICAL: Your previous attempt was detected as AI-written. Attempt {attempt + 1} of {MAX_REGENERATION_ATTEMPTS + 1}.",
        f"Detected problems: {', '.join(descriptions)}",
    ]

    # Escalating instructions based on attempt number
    if attempt == 1:
        feedback_parts.append(
            "Write MORE messily. Use incomplete sentences. Start mid-thought. "
            "Drop the structure entirely. Sound frustrated or excited, not composed."
        )
    elif attempt >= 2:
        feedback_parts.append(
            "MAXIMUM humanization required. Write like you're venting to a friend at 2am. "
            "Grammar mistakes are GOOD. Tangents are GOOD. Abrupt endings are GOOD. "
            "Forget everything you know about writing well."
        )

    return "\n".join(feedback_parts)
```

**Modify generate_draft() method** — Wrap Steps 5 and 6b in a regeneration loop:

Replace the current Step 5 (LLM generation) through Step 6b (AI pattern detection) with a loop:

```python
# Steps 5-6b: Generate with AI pattern detection loop
generated_text = None
model_used = None
token_count = 0
token_cost_usd = 0.0
final_ai_patterns = []
regeneration_attempts = 0

for attempt in range(MAX_REGENERATION_ATTEMPTS + 1):
    # On retry, rebuild prompt with anti-pattern feedback
    current_prompts = prompts
    if attempt > 0:
        anti_pattern_feedback = self._build_anti_pattern_feedback(final_ai_patterns, attempt)
        current_prompts = self.prompt_builder.build_prompt(
            subreddit=request.subreddit,
            archetype=request.archetype,
            user_context=(request.context or "") + f"\n\n{anti_pattern_feedback}",
            profile=profile,
            blacklist_patterns=blacklist_patterns,
            constraints=gating_result["constraints"],
        )
        regeneration_attempts = attempt

    # Step 5: LLM generation
    try:
        inference_result = await inference_client.call(
            prompt=current_prompts["user"],
            system_prompt=current_prompts["system"],
            user_id=user_id,
            plan=plan,
            campaign_id=campaign_id,
        )

        generated_text = inference_result["content"]
        model_used = inference_result["model_used"]
        token_count += inference_result["token_count"]  # Accumulate across retries
        token_cost_usd += inference_result["cost_usd"]  # Accumulate across retries

    except AppError:
        raise
    except Exception as e:
        raise AppError(
            code=ErrorCode.INFERENCE_FAILED,
            message=f"Draft generation failed: {str(e)}",
            details={"subreddit": request.subreddit, "archetype": request.archetype},
            status_code=503
        )

    # Step 6b: AI-pattern detection (blocking quality gate)
    final_ai_patterns = detect_ai_patterns(generated_text)

    if not final_ai_patterns:
        logger.info(f"Draft passed AI detection on attempt {attempt + 1} for r/{request.subreddit}")
        break  # Clean draft, accept it

    if attempt == MAX_REGENERATION_ATTEMPTS:
        logger.warning(
            f"Draft still has {len(final_ai_patterns)} AI patterns after {MAX_REGENERATION_ATTEMPTS + 1} attempts "
            f"for r/{request.subreddit}. Accepting best-effort draft."
        )
        break  # Max retries reached, accept as-is

    logger.info(
        f"AI patterns detected on attempt {attempt + 1} for r/{request.subreddit}: "
        f"{[p['category'] for p in final_ai_patterns]}. Regenerating..."
    )
```

**Update Step 6 (blacklist validation)** to use the final `generated_text` from the loop (it already does, just make sure the variable name matches).

**Update Step 8 (store draft)** — Add regeneration metadata to generation_params:
```python
draft_data["generation_params"]["regeneration_attempts"] = regeneration_attempts
draft_data["generation_params"]["final_ai_patterns"] = len(final_ai_patterns)
draft_data["generation_params"]["structural_template"] = prompts.get("metadata", {}).get("structural_template", "unknown")
```

The token_count and token_cost_usd in the draft record will reflect the TOTAL across all attempts (accumulated in the loop), which correctly represents the actual cost.

**Important:** The `prompts` variable from Step 4 is used for the first attempt. On retries, `current_prompts` is rebuilt via build_prompt(). The `prompts` variable with metadata is still used for template name extraction.
  </action>
  <verify>
Run `python -c "from app.generation.generation_service import GenerationService, MAX_REGENERATION_ATTEMPTS; assert MAX_REGENERATION_ATTEMPTS == 2; gs = GenerationService(); fb = gs._build_anti_pattern_feedback([{'category': 'AI-tidy-ending', 'description': 'Tidy ending'}], 1); assert 'CRITICAL' in fb; print('regeneration loop OK')"` from bc-rao-api directory.

Run `cd bc-rao-api && python -m pytest tests/ -x -q` — all existing tests must pass.

Verify the full import chain: `python -c "from app.generation.generation_service import GenerationService; from app.generation.blacklist_validator import detect_ai_patterns; from app.generation.prompt_builder import PromptBuilder; print('import chain OK')"` from bc-rao-api directory.
  </verify>
  <done>
generate_draft() wraps Steps 5-6b in a loop with MAX_REGENERATION_ATTEMPTS=2 (3 total attempts max). AI patterns trigger automatic regeneration with escalating anti-pattern feedback. Regeneration metadata (attempts, final pattern count, structural template) stored in generation_params. Token costs accumulated across retries. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. All test suites pass: `cd bc-rao-api && python -m pytest tests/ -x -q`
2. AI_TELL_PATTERNS has 12+ patterns covering all 6 new anti-pattern categories
3. Generation pipeline has MAX_REGENERATION_ATTEMPTS=2 blocking loop
4. Anti-pattern feedback escalates across retry attempts
5. generation_params records regeneration_attempts and final_ai_patterns count
6. Import chain intact: generation_service -> blacklist_validator -> prompt_builder
</verification>

<success_criteria>
- AI detection catches all 6 new anti-patterns (symmetrical structure, tidy endings, enumeration, hedge-affirm, generic descriptors, over-enthusiasm)
- Detection is BLOCKING: detected patterns trigger automatic regeneration (not just logging)
- Maximum 3 total attempts (1 + 2 retries) prevents cost explosion
- Regeneration feedback escalates from specific corrections to maximum humanization
- Token costs and attempts tracked in generation_params for monitoring
- All existing tests pass, new tests cover new patterns
</success_criteria>

<output>
After completion, create `.planning/phases/04.1-draft-generation-anti-ai-optimization/04.1-02-SUMMARY.md`
</output>
