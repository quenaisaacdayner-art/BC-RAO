---
phase: 04-draft-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bc-rao-api/app/generation/__init__.py
  - bc-rao-api/app/generation/prompt_builder.py
  - bc-rao-api/app/generation/isc_gating.py
  - bc-rao-api/app/generation/blacklist_validator.py
  - bc-rao-api/app/generation/generation_service.py
  - bc-rao-api/app/models/draft.py
autonomous: true

must_haves:
  truths:
    - "Generation service builds dynamic prompts from community profile data and blacklist"
    - "ISC gating blocks risky archetypes when ISC > 7.5 and forces Feedback with zero links"
    - "Post-generation validation checks draft against regex blacklist patterns"
    - "Account status decision tree enforced (New = warm-up mode, comments only)"
  artifacts:
    - path: "bc-rao-api/app/generation/prompt_builder.py"
      provides: "Dynamic prompt construction from community profiles and blacklists"
      min_lines: 80
    - path: "bc-rao-api/app/generation/isc_gating.py"
      provides: "ISC threshold logic and account status decision tree"
      min_lines: 40
    - path: "bc-rao-api/app/generation/blacklist_validator.py"
      provides: "Post-generation regex validation against forbidden patterns"
      min_lines: 40
    - path: "bc-rao-api/app/generation/generation_service.py"
      provides: "Full generation pipeline orchestration"
      min_lines: 80
    - path: "bc-rao-api/app/models/draft.py"
      provides: "Pydantic models for draft generation requests and responses"
      min_lines: 40
  key_links:
    - from: "bc-rao-api/app/generation/generation_service.py"
      to: "bc-rao-api/app/generation/prompt_builder.py"
      via: "PromptBuilder import and usage"
      pattern: "from app\\.generation\\.prompt_builder import"
    - from: "bc-rao-api/app/generation/generation_service.py"
      to: "bc-rao-api/app/generation/isc_gating.py"
      via: "ISC gating check before generation"
      pattern: "from app\\.generation\\.isc_gating import"
    - from: "bc-rao-api/app/generation/generation_service.py"
      to: "bc-rao-api/app/generation/blacklist_validator.py"
      via: "Post-generation blacklist validation"
      pattern: "from app\\.generation\\.blacklist_validator import"
    - from: "bc-rao-api/app/generation/generation_service.py"
      to: "bc-rao-api/app/inference/client.py"
      via: "InferenceClient for LLM calls"
      pattern: "from app\\.inference\\.client import InferenceClient"
---

<objective>
Build the backend generation pipeline core: prompt construction from community profiles, ISC gating with account status decision tree, post-generation blacklist validation, and the generation service that orchestrates the full pipeline.

Purpose: This is the brain of Module 3 (Conditioning Generator). It transforms community intelligence (profiles, blacklists, ISC scores) into conditioned LLM prompts that produce Reddit-native content. Without this, drafts would be generic and get flagged by moderators.

Output: Generation module with prompt_builder.py, isc_gating.py, blacklist_validator.py, generation_service.py, and draft Pydantic models.
</objective>

<execution_context>
@C:\Users\quena\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\quena\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-draft-generation/04-RESEARCH.md
@bc-rao-api/app/inference/client.py
@bc-rao-api/app/inference/router.py
@bc-rao-api/app/services/analysis_service.py
@bc-rao-api/app/models/analysis.py
@bc-rao-api/app/integrations/supabase_client.py
@bc-rao-api/app/utils/errors.py
@bc-rao-system-spec_1.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Draft models and ISC gating + blacklist validator</name>
  <files>
    bc-rao-api/app/models/draft.py
    bc-rao-api/app/generation/__init__.py
    bc-rao-api/app/generation/isc_gating.py
    bc-rao-api/app/generation/blacklist_validator.py
  </files>
  <action>
    Create `bc-rao-api/app/models/draft.py` with Pydantic models:
    - `GenerateDraftRequest`: subreddit (str), archetype (Literal["Journey", "ProblemSolution", "Feedback"]), context (Optional[str], max_length=2000), account_status (Optional[Literal["New", "WarmingUp", "Established"]], default="Established")
    - `DraftResponse`: id, campaign_id, subreddit, archetype, title, body, vulnerability_score (float), rhythm_match_score (float), blacklist_violations (int), model_used, token_count, token_cost_usd, generation_params (dict), status (Literal["generated","edited","approved","posted","discarded"]), user_edits (Optional), created_at, updated_at
    - `DraftListResponse`: drafts (list[DraftResponse]), total (int)
    - `UpdateDraftRequest`: status (Optional), user_edits (Optional[str])
    - `RegenerateDraftRequest`: feedback (Optional[str], max_length=1000)
    - `BlacklistCheckResult`: passed (bool), violations (list[dict] with pattern, category, matched_text)

    Create `bc-rao-api/app/generation/__init__.py` (empty).

    Create `bc-rao-api/app/generation/isc_gating.py`:
    - `validate_generation_request(subreddit, archetype, account_status, isc_score)` -> returns dict with `allowed` (bool), `forced_archetype` (Optional[str]), `constraints` (list[str]), `reason` (Optional[str])
    - Implement the decision tree from system spec Section 14:
      - If account_status == "New": force Feedback, max vulnerability 0.9, no links, no pitch (warm-up mode)
      - Elif isc_score > 7.5: block ProblemSolution and Journey, force Feedback with max vulnerability, zero links
      - Elif archetype == "ProblemSolution": 90% pain / 10% solution, no greetings, product mention only in last 10%
      - Elif archetype == "Journey": technical diary style, milestones with numbers, metrics required
      - Elif archetype == "Feedback": invert authority, ask community to find flaws, controlled imperfection
    - Return constraints list that gets injected into the prompt

    Create `bc-rao-api/app/generation/blacklist_validator.py`:
    - `validate_draft(draft_text, forbidden_patterns)` -> BlacklistCheckResult
    - Load forbidden patterns (list of dicts with regex_pattern, category, pattern_description)
    - Compile patterns at check time (patterns come from DB, not module-level)
    - Check draft text against each regex pattern
    - Return passed=True if zero violations, passed=False with violation details if any match
    - `calculate_link_density(text)` -> float: count URLs per paragraph
    - `check_sentence_length(text, max_avg)` -> bool: average sentence length within community norm
    - `scan_jargon(text, jargon_list)` -> list[str]: return any jargon terms found
  </action>
  <verify>
    python -c "from app.models.draft import GenerateDraftRequest, DraftResponse, BlacklistCheckResult; from app.generation.isc_gating import validate_generation_request; from app.generation.blacklist_validator import validate_draft; print('All imports OK')"
  </verify>
  <done>
    Draft Pydantic models validate generation requests with max_length constraints. ISC gating returns correct constraints for all 5 decision tree branches. Blacklist validator checks text against regex patterns and returns violation details.
  </done>
</task>

<task type="auto">
  <name>Task 2: Prompt builder and generation service</name>
  <files>
    bc-rao-api/app/generation/prompt_builder.py
    bc-rao-api/app/generation/generation_service.py
  </files>
  <action>
    Create `bc-rao-api/app/generation/prompt_builder.py`:
    - `PromptBuilder` class with `build_prompt(subreddit, archetype, user_context, profile, blacklist_patterns, constraints)` -> dict with "system" and "user" keys
    - GENERIC_DEFAULTS dict for when no community profile exists (isc_score=5.0, formality="Casual but clear", rhythm="Mixed sentence lengths")
    - System prompt template includes: community DNA (ISC score, tier, formality, rhythm from profile), archetype rules (from decision tree constraints), forbidden patterns (formatted by category, max 3 per category to limit token usage), ISC gating rules
    - User prompt template includes: archetype, user_context, archetype-specific guidance
    - `_build_generic_prompt()` for subreddits without community profiles - use GENERIC_DEFAULTS, skip blacklist section
    - `_format_blacklist(patterns)` formats forbidden patterns grouped by category
    - `_describe_rhythm(rhythm_metadata)` summarizes rhythm data (avg sentence length, sentence length variance, formality)
    - `_format_isc_rules(isc_score, archetype)` produces ISC-appropriate constraints

    Create `bc-rao-api/app/generation/generation_service.py`:
    - `GenerationService` class
    - `async generate_draft(campaign_id, user_id, plan, request: GenerateDraftRequest)` orchestrates the full pipeline:
      1. Load community profile from Supabase (community_profiles table) for the given subreddit+campaign_id
      2. Load syntax blacklist from Supabase (syntax_blacklist table) for the given subreddit+campaign_id
      3. Run ISC gating validation (isc_gating.validate_generation_request) - raise AppError if blocked
      4. Build prompt via PromptBuilder (pass profile, blacklist, constraints)
      5. Call InferenceClient(task="generate_draft").call() with the built prompt
      6. Post-process: run blacklist_validator.validate_draft() on generated text
      7. Calculate vulnerability_score and rhythm_match_score from the generated text using the scorers from app.analysis.scorers (calculate_post_score with the NLP pipeline)
      8. Store draft in generated_drafts table via Supabase insert
      9. Return DraftResponse with all fields populated
    - `async get_drafts(campaign_id, user_id, status, subreddit, limit, offset)` -> DraftListResponse
    - `async update_draft(draft_id, user_id, update: UpdateDraftRequest)` -> DraftResponse (update status or user_edits)
    - `async regenerate_draft(draft_id, user_id, plan, feedback)` -> DraftResponse (load original draft params, append feedback to context, generate new draft)
    - `async delete_draft(draft_id, user_id)` -> None
    - Use existing InferenceClient from app.inference.client (NOT a separate OpenAI SDK - per project decision)
    - Use existing Supabase client pattern from app.integrations.supabase_client
    - Handle profile absence gracefully: if no community profile, log warning and generate with generic defaults (per user decision)
  </action>
  <verify>
    python -c "from app.generation.prompt_builder import PromptBuilder; from app.generation.generation_service import GenerationService; print('All imports OK')"
  </verify>
  <done>
    PromptBuilder constructs dynamic prompts with community DNA, blacklist patterns, and ISC rules. GenerationService orchestrates the full pipeline: profile load -> blacklist load -> ISC gating -> prompt build -> LLM call -> post-validation -> scoring -> storage. Generic defaults used when no profile exists.
  </done>
</task>

</tasks>

<verification>
1. All generation module files exist under bc-rao-api/app/generation/
2. ISC gating correctly blocks Journey/ProblemSolution when ISC > 7.5
3. Account status "New" forces Feedback archetype with warm-up constraints
4. Blacklist validator catches regex pattern matches in draft text
5. PromptBuilder produces different prompts for profiled vs unprofiled subreddits
6. GenerationService uses InferenceClient (not separate OpenAI SDK)
7. Draft models match generated_drafts table schema from system spec
</verification>

<success_criteria>
- Generation pipeline can build conditioned prompts from community profiles
- ISC gating enforces all 5 decision tree branches
- Post-generation validation catches blacklist violations
- Drafts stored with vulnerability_score, rhythm_match_score, model_used, token_cost
- Profile absence handled with generic defaults (no crashes)
</success_criteria>

<output>
After completion, create `.planning/phases/04-draft-generation/04-01-SUMMARY.md`
</output>
