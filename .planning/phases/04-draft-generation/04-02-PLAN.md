---
phase: 04-draft-generation
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - bc-rao-api/app/api/v1/drafts.py
  - bc-rao-api/app/api/v1/router.py
  - bc-rao-api/app/workers/generation_worker.py
  - bc-rao-api/app/workers/task_runner.py
autonomous: true

must_haves:
  truths:
    - "POST /campaigns/:id/drafts/generate triggers draft generation and streams progress via SSE"
    - "GET /campaigns/:id/drafts returns draft list filtered by status and subreddit"
    - "PATCH /drafts/:id updates draft status (approve/discard) and user_edits"
    - "POST /drafts/:id/regenerate creates new draft with optional feedback"
    - "Draft generation enforces monthly plan limits (drafts/month per tier)"
  artifacts:
    - path: "bc-rao-api/app/api/v1/drafts.py"
      provides: "FastAPI endpoints for draft generation, listing, updating, regenerating"
      min_lines: 100
    - path: "bc-rao-api/app/workers/generation_worker.py"
      provides: "Celery task for background draft generation with progress tracking"
      min_lines: 50
  key_links:
    - from: "bc-rao-api/app/api/v1/drafts.py"
      to: "bc-rao-api/app/generation/generation_service.py"
      via: "GenerationService import for all draft operations"
      pattern: "from app\\.generation\\.generation_service import"
    - from: "bc-rao-api/app/api/v1/drafts.py"
      to: "bc-rao-api/app/api/v1/router.py"
      via: "Router inclusion"
      pattern: "drafts\\.router"
    - from: "bc-rao-api/app/workers/generation_worker.py"
      to: "bc-rao-api/app/generation/generation_service.py"
      via: "GenerationService call in Celery task"
      pattern: "GenerationService"
---

<objective>
Build FastAPI endpoints for draft generation (with SSE streaming), draft CRUD operations, and a Celery worker for background generation. This exposes the generation pipeline from Plan 01 as an API.

Purpose: Without API endpoints, the frontend cannot trigger generation or manage drafts. The SSE streaming endpoint provides real-time feedback during generation. Monthly plan limits prevent abuse.

Output: FastAPI router with 5 endpoints (generate, list, update, regenerate, delete), Celery worker for async generation, router.py updated with drafts inclusion.
</objective>

<execution_context>
@C:\Users\quena\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\quena\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-draft-generation/04-01-SUMMARY.md
@bc-rao-api/app/api/v1/router.py
@bc-rao-api/app/api/v1/collection.py
@bc-rao-api/app/api/v1/analysis.py
@bc-rao-api/app/workers/task_runner.py
@bc-rao-api/app/workers/collection_worker.py
@bc-rao-api/app/workers/analysis_worker.py
@bc-rao-api/app/dependencies.py
@bc-rao-system-spec_1.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: FastAPI draft endpoints with SSE streaming</name>
  <files>
    bc-rao-api/app/api/v1/drafts.py
    bc-rao-api/app/api/v1/router.py
  </files>
  <action>
    Create `bc-rao-api/app/api/v1/drafts.py` with these endpoints following the patterns from collection.py and analysis.py:

    1. `POST /campaigns/{campaign_id}/drafts/generate` — Trigger draft generation
       - Auth: require JWT via get_current_user dependency
       - Validate: campaign belongs to user (Supabase RLS handles this)
       - Check monthly draft limit: query generated_drafts count for user this month, compare against PLAN_LIMITS[plan]["drafts_month"] from system spec (trial=10, starter=50, growth=unlimited). If exceeded, return 403 with PLAN_LIMIT_REACHED error.
       - Accept GenerateDraftRequest body (subreddit, archetype, context, account_status)
       - Kick off Celery task (generation_worker.generate_draft_task) with campaign_id, user_id, plan, request data
       - Return 202 with task_id for SSE progress tracking

    2. `GET /campaigns/{campaign_id}/drafts/generate/stream/{task_id}` — SSE stream for generation progress
       - Follow SSE proxy pattern from collection.py
       - Stream events: {"type": "status", "message": "Loading community profile..."}, {"type": "status", "message": "Building prompt..."}, {"type": "status", "message": "Generating draft..."}, {"type": "chunk", "content": "..."} (streamed text chunks), {"type": "complete", "draft": DraftResponse}, {"type": "error", "message": "..."}
       - Use FastAPI StreamingResponse with media_type="text/event-stream"
       - Poll Celery task state every 500ms for progress updates
       - No authentication required (task_id is unguessable UUID, same pattern as collection SSE)

    3. `GET /campaigns/{campaign_id}/drafts` — List drafts
       - Auth required
       - Query params: status (optional), subreddit (optional), limit (default 20), offset (default 0)
       - Delegate to GenerationService.get_drafts()
       - Return DraftListResponse

    4. `PATCH /drafts/{draft_id}` — Update draft (approve, discard, edit)
       - Auth required
       - Accept UpdateDraftRequest body
       - Delegate to GenerationService.update_draft()
       - Return DraftResponse

    5. `POST /drafts/{draft_id}/regenerate` — Regenerate draft with feedback
       - Auth required
       - Check monthly draft limit (same as generate)
       - Accept RegenerateDraftRequest body
       - Kick off Celery task for regeneration
       - Return 202 with task_id

    6. `DELETE /drafts/{draft_id}` — Delete draft
       - Auth required
       - Delegate to GenerationService.delete_draft()
       - Return 204

    Update `bc-rao-api/app/api/v1/router.py`:
    - Import drafts module
    - Add `router.include_router(drafts.router, tags=["drafts"])`
  </action>
  <verify>
    python -c "from app.api.v1.drafts import router; print(f'Routes: {len(router.routes)}'); from app.api.v1.router import router as main; print('Main router OK')"
  </verify>
  <done>
    Six draft endpoints registered: generate (POST), stream (GET SSE), list (GET), update (PATCH), regenerate (POST), delete (DELETE). Monthly plan limits enforced on generate and regenerate. SSE streaming follows established collection pattern. Router.py includes drafts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Celery generation worker with progress tracking</name>
  <files>
    bc-rao-api/app/workers/generation_worker.py
    bc-rao-api/app/workers/task_runner.py
  </files>
  <action>
    Create `bc-rao-api/app/workers/generation_worker.py` following the pattern from collection_worker.py and analysis_worker.py:

    - `generate_draft_task(campaign_id, user_id, plan, subreddit, archetype, context, account_status)` — Celery task
      - Queue: "generation" (matches celery_app.py routing)
      - Update task state with progress: "Loading community profile" -> "Checking ISC gating" -> "Building prompt" -> "Generating draft via LLM" -> "Validating against blacklist" -> "Scoring draft" -> "Saving draft"
      - Use `self.update_state(state='PROGRESS', meta={...})` for progress events
      - Call GenerationService.generate_draft() (bridge async with asyncio.run, same pattern as collection_worker)
      - On success: update state to SUCCESS with draft data (DraftResponse serialized)
      - On failure: update state to FAILURE with error message
      - Handle AppError from ISC gating (blocked archetype) as a user-facing error, not a system failure

    - `regenerate_draft_task(draft_id, user_id, plan, feedback)` — Celery task for regeneration
      - Same queue and progress pattern
      - Call GenerationService.regenerate_draft()

    Update `bc-rao-api/app/workers/task_runner.py`:
    - Import generation_worker module so Celery discovers tasks
    - Add to the existing task discovery pattern (follow how collection_worker and analysis_worker are imported)
  </action>
  <verify>
    python -c "from app.workers.generation_worker import generate_draft_task, regenerate_draft_task; print('Generation worker tasks imported OK')"
  </verify>
  <done>
    Celery generation worker runs draft generation as async background task with progress tracking. Task state updates allow SSE endpoint to stream progress. Regeneration task accepts optional feedback. Both tasks route to "generation" queue.
  </done>
</task>

</tasks>

<verification>
1. All 6 draft endpoints accessible via FastAPI router
2. Monthly draft limits enforced (403 when exceeded)
3. SSE streaming works for generation progress
4. Celery tasks register in "generation" queue
5. Worker progress updates match SSE event format
6. Regeneration preserves original draft params and appends feedback
</verification>

<success_criteria>
- POST /campaigns/:id/drafts/generate returns 202 with task_id
- GET stream endpoint delivers SSE events during generation
- GET /campaigns/:id/drafts returns filtered draft list
- PATCH /drafts/:id updates status and user_edits
- POST /drafts/:id/regenerate creates new draft with feedback
- Monthly limits prevent generation beyond plan cap
</success_criteria>

<output>
After completion, create `.planning/phases/04-draft-generation/04-02-SUMMARY.md`
</output>
